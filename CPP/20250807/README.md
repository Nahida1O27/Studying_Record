参考资料  
《C++语言程序设计(第5版)》郑莉、董渊编著 清华大学出版社 ISBN:9787302566915  

---  
>Point类的复制构造函数被调用了6次，而且都是在Line类构造函数体运行之前进行的，它们分别是**两个对象在Line构造函数进行函数参数形实结合时**，**初始化内嵌对象时**，以及**复制构造line2时**被调用的。——P123  

书中其实说得很明确了。但我第一次读没看懂，所以加一点自己个人的理解。  
# 输出结果的截图：    
![](./running%20result.png)  
分析[main.cpp](./main.cpp)的51-53行  

```cpp
    Point myp1(1,1),myp2(4,5);
    Line line(myp1,myp2);
    Line line2(line);
```

51行定义（构建）了两个构造函数，自然不会调用复制构造函数。  

52行把51行所定义的两个对象myp1和myp2作为参数传入line类的复制构造函数。在函数体内形参只是局部有效。[截图](./running%20result.png)的前两行应该是（~~吧~~）line构造函数体内由Point类的复制构造函数临时创建两个对象，即从<u>myp1、myp2</u>复制给<u>两个临时对象</u>；由于函数体内对象是临时占用内存的，函数结束后要释放掉，所以  
三四行打印的是从<u>两个临时Point对象</u>复制到<u>line对象的私有数据成员p1、p2</u>  
第五行打印的是：line对象顺利创建，构造函数调用完成  

为了印证临时对象的猜想是否正确，我添加了原书代码，加了一个析构函数查看Point对象的销毁情况：[main.cpp](./main.cpp)的24-26行  
```cpp
Point::~Point(){
    cout<<"召唤Point类的析构函数"<<endl;
}
```
事实也如预想的一样，六七行打印了，代表函数体内两个临时对象被销毁了，顺利解释了为什么会调用四次复制构造函数。  

那53行同样是新定义一个线段对象，为什么不打印4次Point类复制构造函数呢？  
八九行打印的是line2的两个内嵌对象的创建，这点没异议  
我想关键在于Line类的构造函数、复制构造函数之间的不同。
Line类构造函数的参数是Point对象作形参，发生值传递；而复制构造函数的参数是Line对象的传递引用  
>只有把对象用值传递时，才会调用复制构造函数，如果传递引用，则不会调用复制构造函数。——P112的提示

因为是传引用，所以打印了2行信息（~~应该是吧~~）  
第十行打印的是：line2对象顺利从line对象拷贝成功，复制构造函数调用完成  

**分析完毕**  

---  
这是我亲手打的第一篇markdown和第一个github的文件夹。以上分析如果有问题欢迎批评指正  
C++是大一下学期学的，如今两年过去了，忘完了。要大四了啥都没学，学个C语言用了三年。  

今天发现测试P122这个夹杂了**类的组合**和**复制构造函数**这两个语法的程序挺有趣的，遂记成文档分享与世人。

